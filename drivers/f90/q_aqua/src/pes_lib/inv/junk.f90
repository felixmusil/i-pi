PROGRAM test_mg
use inv, wp=>inv_wp
implicit none
integer, parameter :: mxm_test=10 !! 5000
integer, parameter :: mxd=19, nk=mg111_nk, nr=mg111_nr, &
  nkj(0:size(mg111_nkj)-1)=mg111_nkj, m=mg111_nb(mxd), mpb=mg111_npb(mxd), &
  mvec=mgv111_nb(mxd), ntst=2*m, lwork=20*ntst
real (kind=wp), parameter :: rcond=1e-12_wp
logical :: b0
integer :: i, j, k, m0, info, iord(0:nk-1), gen0(0:nr-1)
real (kind=wp) :: t0, x(0:nr-1), y(0:nr-1), z(0:nr-1), &
  u(0:nr-1), u0(0:nr-1), v(0:mg111_nsc(mxd)-1), &
  v0(0:mg111_nsc(mxd)-1), r(0:nk-1,0:nk-1), r1(0:nk-1,0:nk-1)
real (kind=wp) :: w(0:m-1), w0(0:m-1), wvec(0:nk-1,0:mvec-1), &
  w1vec(0:nk-1,0:mvec-1), wpb(0:mpb-1), wpb0(0:mpb-1)
real (kind=wp), allocatable :: mat(:,:), sval(:), scal(:), svu(:,:), &
  svvt(:,:), work(:)
! test the parameters
if (nr.ne.nk*(nk-1)/2.or. &
  sum(nkj).ne.nk) then
 stop 'test - nkj, nk, nr parameter fault'
endif
if (product(factorial(nkj)).ne.mg111_ngrp) then
 stop 'test - nkj, ngrp parameter fault'
endif
do k = 0, size(mg111_nb)-1
 if (mg111_npr(k).ne.sum(mg111_dnpr(0:k)).or. &
   mg111_nsc(k).ne.sum(mg111_dnsc(0:k)).or. &
   mg111_nb(k).ne.sum(mg111_dnb(0:k))) then
  stop 'test - dimension parameter fault'
 endif
enddo
write (*,*) 'done test parameters'
! test the permutation generators
call random_number (x)
do j = 0, mgx_ngen(nkj)-1
 call mgx_gens (nkj, j, gen0)
 y = x(gen0)
 z(gen0) = y
 if (0.lt.maxval(abs(x-z))) then
  write (*,'(1x,a,2x,i3)') 'bad permutation:', j
 endif
enddo
write (*,*) 'done test permutations'
! test the mk1d, mk2d procedures
call random_number (x)
call mgx_mk2d (nkj, x, r)
call mgx_mk1d (nkj, r, z)
if (any(z.ne.x)) then
 write (*,'(1x,a)') 'bad mk1d, mk2d'
endif
write (*,*) 'done test mk1d, mk2d'
! test the primaries
r = 1
call mg111_prims (r, u)
do j = 0, nr-1
 if (sqrt(epsilon(u)).lt.abs(u(j)-1)) then
  write (*,'(1x,a,2x,i6)') 'bad non-unit prims at element:', j
 endif
enddo
r = 2
call mg111_prims (r, u)
do k = 1, size(mg111_nb)-1
 do j = mg111_npr(k-1), mg111_npr(k)-1
  if (sqrt(epsilon(u)).lt.abs(1-u(j)/2**k)) then
   write (*,'(1x,a,2x,i6)') 'bad prims power at element:', j
  endif
 enddo
enddo
do i = 0, 1
 call random_number (r)
 r = r+transpose(r)-1
 call mg111_prims (r, u0)
 do j = 0, mgx_ngen(nkj)-1
  call mgx_gens2d (nkj, j, iord)
  r1 = r(iord,iord)
  call mg111_prims (r1, u)
  t0 = maxval(abs(u-u0))
  if (sqrt(epsilon(u)).lt.t0) then
   write (*,'(1x,a,2x,i2,2x,i6,es10.2)') 'bad prims permutation:', &
     j, maxloc(abs(u-u0))-1, t0
  endif
 enddo
enddo
write (*,*) 'done test prims'
! test the base generated by the primaries
u = 1
call mg111_prib (mxd, u, wpb)
do j = 0, mpb-1
 if (sqrt(epsilon(wpb)).lt.abs(wpb(j)-1)) then
  write (*,'(1x,a,2x,i6)') 'bad non-unit prib at element:', j
 endif
enddo
write (*,*) 'done test prib units'
do i = 0, 1
 call random_number (r)
 r = r+transpose(r)-1
 call mg111_prims (r, u)
 call mg111_prib (mxd, u, wpb0)
 r = 2*r
 call mg111_prims (r, u)
 call mg111_prib (mxd, u, wpb)
 if (wpb(0).ne.1) then
  write (*,'(1x,a,2x,i6)') 'bad degree(0) prib at element:', 0
 endif
 do k = 1, mxd
  do j = mg111_npb(k-1), mg111_npb(k)-1
   if (sqrt(epsilon(wpb)).lt.abs(wpb0(j)-wpb(j)/2**k)) then
    write (*,'(1x,a,2x,i6)') 'bad exponent prib at element:', j
   endif
  enddo
 enddo
enddo
write (*,*) 'done test prib scaling'
do i = 0, 1
 call random_number (r)
 r = r+transpose(r)-1
 call mg111_prims (r, u)
 call mg111_prib (mxd, u, wpb0)
 do j = 0, mgx_ngen(nkj)-1
  call mgx_gens2d (nkj, j, iord)
  r1 = r(iord,iord)
  call mg111_prims (r1, u)
  call mg111_prib (mxd, u, wpb)
  t0 = maxval(abs(wpb-wpb0))
  if (sqrt(epsilon(wpb)).lt.t0) then
   write (*,'(1x,a,2x,i2,2x,i6,es10.2)') 'bad prib perm result:', &
     j, maxloc(abs(wpb-wpb0))-1, t0
  endif
 enddo
enddo
write (*,*) 'done test prib perms'
! test the secondaries
! (don't print any error message more than one)
r = 1
call mg111_secs (mxd, r, v)
b0 = .false.
do j = 0, mg111_nsc(mxd)-1
 if (sqrt(epsilon(v)).lt.abs(v(j)-1).and..not.b0) then
  write (*,'(1x,a,2x,i6)') 'bad non-unit secs at element:', j
  b0 = .true.
 endif
enddo
r = 2
call mg111_secs (mxd, r, v)
b0 = .false.
do k = 1, mxd
 do j = mg111_nsc(k-1), mg111_nsc(k)-1
  if (sqrt(epsilon(v)).lt.abs(1-v(j)/2**k).and..not.b0) then
   write (*,'(1x,a,2x,i6)') 'bad secs power at element:', j
   b0 = .true.
  endif
 enddo
enddo
do i = 0, 1
 call random_number (r)
 r = r+transpose(r)-1
 call mg111_secs (mxd, r, v0)
 do j = 0, mgx_ngen(nkj)-1
 b0 = .false.
  call mgx_gens2d (nkj, j, iord)
  r1 = r(iord,iord)
  call mg111_secs (mxd, r1, v)
  t0 = maxval(abs(v-v0))
  if (sqrt(epsilon(v)).lt.t0.and..not.b0) then
   write (*,'(1x,a,2x,i2,2x,i6,es10.2)') 'bad secs permutation:', &
     j, maxloc(abs(v-v0))-1, t0
   b0 = .true.
  endif
 enddo
enddo
write (*,*) 'done test secs'
! test elementary properties of the basis
! (don't print any error message more than one)
r = 1
call mg111_base (mxd, r, w)
b0 = .false.
do j = 0, m-1
 if (sqrt(epsilon(w)).lt.abs(w(j)-1).and..not.b0) then
  write (*,'(1x,a,2x,i6)') 'bad non-unit base at element:', j
  b0 = .true.
 endif
enddo
write (*,*) 'done test base units'
do i = 0, 1
 call random_number (r)
 r = r+transpose(r)-1
 call mg111_base (mxd, r, w0)
 r = 2*r
 call mg111_base (mxd, r, w)
 if (w(0).ne.1) then
  write (*,'(1x,a,2x,i6)') 'bad degree(0) result at element:', 0
 endif
 b0 = .false.
 do k = 1, mxd
  do j = mg111_nb(k-1), mg111_nb(k)-1
   if (sqrt(epsilon(w)).lt.abs(w0(j)-w(j)/2**k).and..not.b0) then
    write (*,'(1x,a,2x,i6)') 'bad exponent result at element:', j
    b0 = .true.
   endif
  enddo
 enddo
enddo
write (*,*) 'done test base scaling'
do i = 0, 1
 call random_number (r)
 r = r+transpose(r)-1
 call mg111_base (mxd, r, w0)
 do j = 0, mgx_ngen(nkj)-1
  call mgx_gens2d (nkj, j, iord)
  r1 = r(iord,iord)
  call mg111_base (mxd, r1, w)
  t0 = maxval(abs(w-w0))
  if (sqrt(epsilon(w)).lt.t0) then
   write (*,'(1x,a,2x,i2,2x,i6,es10.2)') 'bad perm result:', &
     j, maxloc(abs(w-w0))-1, t0
  endif
 enddo
enddo
write (*,*) 'done test base perms'
! test elementary properties of the vector basis
do i = 0, 1
 call random_number (r)
 r = r+transpose(r)-1
 call mgv111_base (mxd, r, wvec)
 do j = 0, mgx_ngen(nkj)-1
  call mgx_gens2d (nkj, j, iord)
  r1 = r(iord,iord)
  call mgv111_base (mxd, r1, w1vec)
  t0 = maxval(abs(w1vec-wvec(iord,:)))
  if (sqrt(epsilon(w1vec)).lt.t0) then
   write (*,'(1x,a,2x,i2,2(1x,i6),es10.2)') 'bad vector perm result:', &
     j, maxloc(abs(w1vec-wvec))-1, t0
  endif
 enddo
enddo
write (*,*) 'done test vector base perms'
! maybe test basis condition
if (m.lt.mxm_test) then
 allocate (mat(0:ntst-1,0:m-1), sval(0:m-1), scal(0:ntst-1), &
   svu(0:ntst-1,0:m-1), svvt(0:m-1,0:m-1), work(0:lwork-1))
 do i = 0, ntst-1
  call random_number (r)
  r = r+transpose(r)-1
  call mg111_base (mxd, r, mat(i,0:m-1))
 enddo
 do i = 0, m-1
  scal(i) = sqrt(sum(mat(0:ntst-1,i)**2)/ntst)
  mat(0:ntst-1,i) = mat(0:ntst-1,i)/scal(i)
 enddo
 call dgesvd ('s', 's', ntst, m, mat, ntst, sval, svu, ntst, svvt, &
   m, work, lwork, info)
 i = m
 do while (sval(i-1).lt.rcond*sval(0))
  i = i-1
 enddo
 m0 = i
 write (*,'(2(2x,i4),2x,es9.2,2x,5es9.2)') m, m0, sval(0), &
   sval(m-5), sval(m-4), sval(m-3), sval(m-2), sval(m-1)
 write (*,*) 'done test basis condition'
else
 write (*,*) 'no test of basis condition'
endif
stop
CONTAINS
ELEMENTAL FUNCTION factorial (k) RESULT (n)
integer, intent (in) :: k
integer :: n
integer :: n0, i
n0 = 1
do i = 2, k
 n0 = n0*i
enddo
n = n0
return
END FUNCTION factorial
END PROGRAM test_mg
